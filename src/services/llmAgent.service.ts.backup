import { UserPosition } from './position.service';
import { analyticsDataStore } from './analyticsDataStore.service';
import { configManager } from '../config/config.manager';
import chalk from 'chalk';

// ==================== TYPES ====================

export interface LLMDecisionContext {
    timestamp: number;

    position: {
        address: string;
        poolAddress: string;
        inRange: boolean;
        activeBin: number;
        rangeBins: [number, number];
        distanceToEdge: number;
        ageHours: number;
        unclaimedFeesUsd: number;
        binUtilization: number;
    };

    market: {
        currentPrice: number;
        priceChange6h: number;
        volatilityScore: number;
        volumeRatio: number;
        volumeTrend: 'increasing' | 'decreasing' | 'stable';
    };

    // NEW: Intraday analysis from hourly snapshots
    intraDayAnalysis?: {
        hourlySnapshots: number;  // Count of snapshots available
        momentum: {
            price: number;           // Average hourly price change %
            volume: number;          // Volume acceleration %
            direction: 'bullish' | 'bearish' | 'neutral';
        };
        signals: {
            priceBreakout: boolean;  // Price at extremes
            volumeSpike: boolean;    // Volume > 1.5x average
            volatilityShift: boolean; // Volatility increased
        };
    };

    fees: {
        actualDaily: number;
        expectedDaily: number;
        efficiency: number;
        claimableUsd: number;
    };

    costs: {
        rebalanceCostUsd: number;
        breakEvenHours: number;
        minROI: number;
    };

    history: {
        totalRebalances: number;
        successRate: number;
        avgBreakEvenHours: number;
        lastRebalance?: {
            timestamp: number;
            reason: string;
            roi: number;
        };
        patterns: string[];
    };
}

export interface LLMDecision {
    action: 'rebalance' | 'hold' | 'compound' | 'widen_range' | 'narrow_range';
    confidence: number;
    urgency: 'critical' | 'high' | 'medium' | 'low';
    reasoning: string[];
    expectedOutcome: {
        costUsd: number;
        expectedFeesNext24h: number;
        breakEvenHours: number;
        roi: number;
    };
    alternativeAction?: string;
    risks: string[];
    learnings?: string;
}

export interface LLMDecisionLog {
    timestamp: number;
    positionAddress: string;
    context: LLMDecisionContext;
    decision: LLMDecision;
    approved: boolean | null;
    approvedAt: number | null;
    executedAt: number | null;
    actualOutcome: {
        feesEarned24h: number;
        actualROI: number;
        success: boolean;
    } | null;
}

export type LLMProvider = 'anthropic' | 'openai' | 'deepseek' | 'grok' | 'kimi' | 'gemini' | 'none';

export interface LLMProviderConfig {
    provider: LLMProvider;
    apiKey: string;
    model: string;
    baseURL?: string;
}

// ==================== POSITION CREATION TYPES ====================

export interface PoolCreationContext {
    timestamp: number;

    pool: {
        address: string;
        tokenX: string;
        tokenY: string;
        binStep: number;
        currentPrice: number;
        activeBinId: number;
        tvl: number;
        apr: number;
    };

    market: {
        priceHistory30d: {
            min: number;
            max: number;
            current: number;
            volatility: number;
            trend: 'bullish' | 'bearish' | 'neutral';
        };
        volume: {
            current24h: number;
            avg7d: number;
            ratio: number;
            trend: 'increasing' | 'decreasing' | 'stable';
        };
        technicals: {
            atr: number;
            atrState: 'expanding' | 'flat' | 'contracting';
            supportLevels: number[];
            resistanceLevels: number[];
        };
    };

    pairCharacteristics: {
        isStablePair: boolean;
        hasStable: boolean;
        volatilityScore: number;
        volumeSkew: number;  // Bid vs Ask volume
    };
}

export interface PoolCreationRecommendation {
    strategy: 'Spot' | 'Curve' | 'BidAsk';
    confidence: number;
    reasoning: string[];

    binConfiguration: {
        minBinId: number;
        maxBinId: number;
        bidBins: number;
        askBins: number;
        totalBins: number;
    };

    liquidityDistribution: {
        tokenXPercentage: number;  // 0-100
        tokenYPercentage: number;  // 0-100
        isAsymmetric: boolean;
    };

    expectedPerformance: {
        estimatedAPR: number;
        feeEfficiency: number;
        rebalanceFrequency: 'high' | 'medium' | 'low';
    };

    risks: string[];
    marketRegime: string;
}

// ==================== SERVICE ====================

export class LLMAgentService {
    private providerConfig: LLMProviderConfig | null = null;
    private client: any = null;

    constructor() {
        try {
            this.providerConfig = this.loadProviderConfig();
            if (this.providerConfig.provider !== 'none') {
                this.client = this.initializeClient();
            }
        } catch (error) {
            console.log(chalk.yellow('‚ö†Ô∏è  LLM Agent not configured. Decisions will be mock-only.'));
            this.providerConfig = { provider: 'none', apiKey: '', model: '' };
        }
    }

    private loadProviderConfig(): LLMProviderConfig {
        const config = configManager.getConfig();
        const llmConfig = config.preferences.llm;

        if (!llmConfig || llmConfig.provider === 'none') {
            return { provider: 'none', apiKey: '', model: '' };
        }

        const apiKey = llmConfig.apiKey ? configManager.decryptPrivateKey(llmConfig.apiKey) : '';

        return {
            provider: llmConfig.provider as LLMProvider,
            apiKey,
            model: llmConfig.model || '',
            baseURL: llmConfig.baseURL
        };
    }

    private initializeClient(): any {
        if (!this.providerConfig) {
            throw new Error('Provider config not loaded');
        }

        const { provider, apiKey, baseURL } = this.providerConfig;

        try {
            switch (provider) {
                case 'anthropic': {
                    const Anthropic = require('@anthropic-ai/sdk');
                    return new Anthropic({ apiKey });
                }
                case 'openai':
                case 'deepseek':
                case 'grok':
                case 'kimi':
                case 'gemini': {
                    const OpenAI = require('openai');
                    return new OpenAI({
                        apiKey,
                        baseURL: baseURL || (provider === 'openai' ? undefined : baseURL)
                    });
                }
                default:
                    throw new Error(`Unsupported provider: ${provider}`);
            }
        } catch (error: any) {
            if (error.code === 'MODULE_NOT_FOUND') {
                console.log(chalk.yellow(`\n‚ö†Ô∏è  SDK not installed for ${provider}`));
                console.log(chalk.gray('Install with: npm install @anthropic-ai/sdk openai'));
                return null;
            }
            throw error;
        }
    }

    isAvailable(): boolean {
        return this.providerConfig !== null &&
            this.providerConfig.provider !== 'none' &&
            this.client !== null;
    }

    async analyzePosition(position: UserPosition): Promise<LLMDecision> {
        if (!this.isAvailable()) {
            return this.getMockDecision(position);
        }

        try {
            const context = await this.buildContext(position);
            const decision = await this.getLLMDecision(context);
            await this.logDecision(position.publicKey, context, decision);
            return decision;
        } catch (error: any) {
            console.error(chalk.red(`\n‚ùå LLM Analysis failed: ${error.message}`));
            return this.getMockDecision(position);
        }
    }

    /**
     * Analyze a pool for optimal position creation
     */
    async analyzePoolForCreation(poolInfo: any): Promise<PoolCreationRecommendation> {
        if (!this.isAvailable()) {
            return this.getMockCreationRecommendation(poolInfo);
        }

        try {
            const context = await this.buildCreationContext(poolInfo);
            const recommendation = await this.getCreationRecommendation(context);
            return recommendation;
        } catch (error: any) {
            console.error(chalk.red(`\n‚ùå LLM Creation Analysis failed: ${error.message}`));
            return this.getMockCreationRecommendation(poolInfo);
        }
    }

    private async buildContext(position: UserPosition): Promise<LLMDecisionContext> {
        const { poolService } = require('./pool.service');
        const { meteoraVolumeCache } = require('./meteoraVolume.service');
        const { marketContextService } = require('./market-context.service');
        const { oracleService } = require('./oracle.service');
        const { hourlySnapshotService } = require('./hourlySnapshot.service');

        const poolInfo = await poolService.getPoolInfo(position.poolAddress);
        const volumeData = await meteoraVolumeCache.getVolume(position.poolAddress);
        const marketContext = await marketContextService.buildRangeContext(poolInfo);

        const snapshots = analyticsDataStore.getPositionSnapshots(position.publicKey, 7);
        const latestSnapshot = snapshots[snapshots.length - 1];

        const distanceToEdge = Math.min(
            position.activeBinId - position.lowerBinId,
            position.upperBinId - position.activeBinId
        );

        const rebalanceHistory = analyticsDataStore
            .loadRebalanceHistory()
            .filter((r: any) => r.oldPositionAddress === position.publicKey);

        const lastRebalance = rebalanceHistory[rebalanceHistory.length - 1];
        const ageHours = lastRebalance
            ? (Date.now() - lastRebalance.timestamp) / (1000 * 60 * 60)
            : Infinity;

        const successful = rebalanceHistory.filter((r: any) => {
            const roi = r.feesClaimedUsd / r.transactionCostUsd;
            return roi >= 2.0;
        });
        const successRate = rebalanceHistory.length > 0
            ? (successful.length / rebalanceHistory.length) * 100
            : 0;

        const volumeTrend = analyticsDataStore.getVolumeTrend(position.poolAddress);

        let priceChange6h = 0;
        try {
            const priceHistory = await oracleService.getUsdPriceSeries(poolInfo.tokenX.mint, 6);
            if (priceHistory && priceHistory.length >= 2) {
                const firstPrice = priceHistory[0].price;
                const lastPrice = priceHistory[priceHistory.length - 1].price;
                priceChange6h = ((lastPrice - firstPrice) / firstPrice) * 100;
            }
        } catch (error) {
            // Ignore
        }

        // Get intraday context from hourly snapshots
        let intraDayAnalysis: LLMDecisionContext['intraDayAnalysis'];
        try {
            const intraDayContext = hourlySnapshotService.getIntraDayContext(position.poolAddress, 24);
            if (intraDayContext.snapshots.length > 0) {
                intraDayAnalysis = {
                    hourlySnapshots: intraDayContext.snapshots.length,
                    momentum: intraDayContext.momentum,
                    signals: intraDayContext.signals
                };
            }
        } catch (error) {
            // Intraday data is optional, don't fail if unavailable
        }

        return {
            timestamp: Date.now(),
            position: {
                address: position.publicKey,
                poolAddress: position.poolAddress,
                inRange: position.inRange,
                activeBin: position.activeBinId,
                rangeBins: [position.lowerBinId, position.upperBinId],
                distanceToEdge,
                ageHours,
                unclaimedFeesUsd: position.unclaimedFees.usdValue || 0,
                binUtilization: latestSnapshot?.binUtilization?.utilizationPercent || 0
            },
            market: {
                currentPrice: poolInfo.price || 0,
                priceChange6h,
                volatilityScore: marketContext.volatilityScore || 0,
                volumeRatio: volumeData.volumeRatio,
                volumeTrend
            },
            intraDayAnalysis,
            fees: {
                actualDaily: latestSnapshot?.feePerformance?.actualDailyFeesUsd || 0,
                expectedDaily: latestSnapshot?.feePerformance?.expectedDailyFeesUsd || 0,
                efficiency: latestSnapshot?.feePerformance?.efficiency || 0,
                claimableUsd: position.unclaimedFees.usdValue || 0
            },
            costs: {
                rebalanceCostUsd: 0.028,
                breakEvenHours: 0,
                minROI: 2.0
            },
            history: {
                totalRebalances: rebalanceHistory.length,
                successRate,
                avgBreakEvenHours: this.calculateAvgBreakEven(rebalanceHistory),
                lastRebalance: lastRebalance ? {
                    timestamp: lastRebalance.timestamp,
                    reason: lastRebalance.reason,
                    roi: lastRebalance.feesClaimedUsd / lastRebalance.transactionCostUsd
                } : undefined,
                patterns: this.detectPatterns(rebalanceHistory)
            }
        };
    }

    private async getLLMDecision(context: LLMDecisionContext): Promise<LLMDecision> {
        const systemPrompt = this.buildSystemPrompt();
        const userMessage = this.buildUserMessage(context);

        if (!this.providerConfig || !this.client) {
            throw new Error('LLM client not initialized');
        }

        const { provider, model } = this.providerConfig;

        try {
            if (provider === 'anthropic') {
                const response = await this.client.messages.create({
                    model,
                    max_tokens: 2000,
                    temperature: 0.3,
                    system: systemPrompt,
                    messages: [{ role: 'user', content: userMessage }]
                });

                const content = response.content[0];
                if (content.type !== 'text') {
                    throw new Error('Unexpected response type');
                }

                return this.parseDecision(content.text);
            } else {
                const response = await this.client.chat.completions.create({
                    model,
                    max_tokens: 2000,
                    temperature: 0.3,
                    messages: [
                        { role: 'system', content: systemPrompt },
                        { role: 'user', content: userMessage }
                    ]
                });

                const content = response.choices[0].message.content;
                return this.parseDecision(content);
            }
        } catch (error: any) {
            console.error(chalk.red(`\n‚ùå LLM API Error: ${error.message}`));
            throw error;
        }
    }

    private buildSystemPrompt(): string {
        return `You are an expert DeFi liquidity provider managing concentrated liquidity positions on Meteora DLMM (Solana).

ROLE:
- Analyze position health, market conditions, and historical performance
- Recommend WHEN to rebalance for maximum fee capture vs gas costs
- Optimize for ROI (target >2x gas cost recovery)
- Learn from historical patterns

CONSTRAINTS:
- NEVER recommend rebalancing unless expected ROI >= configured minimum (usually 2x)
- Consider volume trends (avoid rebalancing during low volume < 0.7x avg)
- Factor in volatility for range width decisions
- Account for break-even time (<24h preferred)
- Respect position age (avoid churning <4h since last rebalance)

DECISION FRAMEWORK:
1. **Out of Range?** ‚Üí URGENT (not earning fees)
2. **Distance to Edge** ‚Üí <5 bins = proactive rebalance
3. **Volume Analysis** ‚Üí >1.5x = good timing, <0.7x = wait
4. **Fee Efficiency** ‚Üí <70% = underperforming
5. **Break-even** ‚Üí Calculate cost / expected daily gain
6. **Historical Success** ‚Üí Learn from past decisions

OUTPUT: Respond ONLY with valid JSON matching this structure:
{
  "action": "rebalance" | "hold" | "compound" | "widen_range" | "narrow_range",
  "confidence": 0-100,
  "urgency": "critical" | "high" | "medium" | "low",
  "reasoning": ["bullet point 1", "bullet point 2", ...],
  "expectedOutcome": {
    "costUsd": number,
    "expectedFeesNext24h": number,
    "breakEvenHours": number,
    "roi": number
  },
  "alternativeAction": "string (optional)",
  "risks": ["risk 1", "risk 2", ...],
  "learnings": "string (optional pattern recognition)"
}`;
    }

    private buildUserMessage(ctx: LLMDecisionContext): string {
        const statusEmoji = ctx.position.inRange ? '‚úÖ' : 'üö®';
        const volumeEmoji = ctx.market.volumeRatio > 1.5 ? 'üìà' : ctx.market.volumeRatio < 0.7 ? 'üìâ' : '‚û°Ô∏è';

        return `POSITION ANALYSIS REQUEST

## Current State
- Position: ${ctx.position.address.slice(0, 8)}...
- Status: ${statusEmoji} ${ctx.position.inRange ? 'IN RANGE' : 'OUT OF RANGE (CRITICAL!)'}
- Active Bin: ${ctx.position.activeBin}
- Range: [${ctx.position.rangeBins[0]}, ${ctx.position.rangeBins[1]}]
- Distance to Edge: **${ctx.position.distanceToEdge} bins** ${ctx.position.distanceToEdge < 5 ? '‚ö†Ô∏è APPROACHING EDGE' : ''}
- Age Since Rebalance: ${ctx.position.ageHours.toFixed(1)}h
- Bin Utilization: ${ctx.position.binUtilization.toFixed(1)}%

## Market Conditions
- Price Change (6h): ${ctx.market.priceChange6h > 0 ? '+' : ''}${ctx.market.priceChange6h.toFixed(2)}%
- Volatility Score: ${ctx.market.volatilityScore.toFixed(3)} ${ctx.market.volatilityScore > 0.15 ? '(HIGH)' : ctx.market.volatilityScore < 0.05 ? '(LOW)' : '(MEDIUM)'}
- Volume Activity: ${volumeEmoji} **${ctx.market.volumeRatio.toFixed(2)}x** vs 7d avg ${ctx.market.volumeRatio > 1.5 ? '(EXCELLENT!)' : ctx.market.volumeRatio < 0.7 ? '(LOW - WAIT)' : '(NORMAL)'}
- Volume Trend: ${ctx.market.volumeTrend.toUpperCase()}

## Fee Performance
- Fee Efficiency: **${ctx.fees.efficiency.toFixed(1)}%** ${ctx.fees.efficiency < 70 ? '‚ö†Ô∏è UNDERPERFORMING' : '‚úÖ GOOD'}
- Actual Daily Fees: $${ctx.fees.actualDaily.toFixed(2)}
- Expected Daily Fees: $${ctx.fees.expectedDaily.toFixed(2)}
- Unclaimed Fees: $${ctx.fees.claimableUsd.toFixed(2)}

## Cost Analysis
- Rebalance Cost: $${ctx.costs.rebalanceCostUsd.toFixed(2)}
- Required ROI: ${ctx.costs.minROI}x
- Min Daily Fees for ROI: $${((ctx.costs.rebalanceCostUsd * ctx.costs.minROI) / 24).toFixed(3)}/hour

## Historical Performance
- Total Past Rebalances: ${ctx.history.totalRebalances}
- Success Rate: ${ctx.history.successRate.toFixed(1)}%
${ctx.history.lastRebalance ? `- Last Rebalance: ${new Date(ctx.history.lastRebalance.timestamp).toLocaleString()}
  - Reason: ${ctx.history.lastRebalance.reason}
  - ROI: ${ctx.history.lastRebalance.roi.toFixed(2)}x` : ''}
${ctx.history.patterns.length > 0 ? `- Learned Patterns:\n${ctx.history.patterns.map(p => `  ‚Ä¢ ${p}`).join('\n')}` : ''}

---

**QUESTION:** Should I take action on this position now? Provide detailed analysis with expected ROI.`;
    }

    private parseDecision(text: string): LLMDecision {
        const jsonMatch = text.match(/```json\n([\s\S]+?)\n```/) || text.match(/\{[\s\S]+\}/);

        if (!jsonMatch) {
            throw new Error('No valid JSON in LLM response');
        }

        const jsonText = jsonMatch[1] || jsonMatch[0];
        const parsed = JSON.parse(jsonText);

        if (!parsed.action || parsed.confidence === undefined || !parsed.reasoning) {
            throw new Error('Invalid decision structure');
        }

        return parsed as LLMDecision;
    }

    private async logDecision(
        positionAddress: string,
        context: LLMDecisionContext,
        decision: LLMDecision
    ): Promise<void> {
        const log: Partial<LLMDecisionLog> = {
            timestamp: Date.now(),
            positionAddress,
            context,
            decision,
            approved: null,
            approvedAt: null,
            executedAt: null,
            actualOutcome: null
        };

        analyticsDataStore.recordLLMDecision(log);
    }

    private getMockDecision(position: UserPosition): LLMDecision {
        const isOutOfRange = !position.inRange;
        const distanceToEdge = Math.min(
            position.activeBinId - position.lowerBinId,
            position.upperBinId - position.activeBinId
        );

        if (isOutOfRange) {
            return {
                action: 'rebalance',
                confidence: 95,
                urgency: 'critical',
                reasoning: ['Position is out of range and not earning fees'],
                expectedOutcome: {
                    costUsd: 0.028,
                    expectedFeesNext24h: 0.1,
                    breakEvenHours: 6.7,
                    roi: 3.6
                },
                risks: ['Mock decision - LLM notconfigured']
            };
        }

        if (distanceToEdge < 5) {
            return {
                action: 'rebalance',
                confidence: 75,
                urgency: 'high',
                reasoning: [`Position is ${distanceToEdge} bins from edge`, 'Proactive rebalance recommended'],
                expectedOutcome: {
                    costUsd: 0.028,
                    expectedFeesNext24h: 0.08,
                    breakEvenHours: 8.4,
                    roi: 2.9
                },
                risks: ['Mock decision - LLM not configured']
            };
        }

        return {
            action: 'hold',
            confidence: 60,
            urgency: 'low',
            reasoning: ['Position is healthy', 'No action needed at this time'],
            expectedOutcome: {
                costUsd: 0,
                expectedFeesNext24h: 0.05,
                breakEvenHours: 0,
                roi: 0
            },
            risks: ['Mock decision - LLM not configured']
        };
    }

    private calculateAvgBreakEven(history: any[]): number {
        if (history.length === 0) return 0;

        const breakEvens = history
            .filter(r => r.feesClaimedUsd > 0)
            .map(r => {
                const hourlyFees = r.feesClaimedUsd / 24;
                return r.transactionCostUsd / hourlyFees;
            });

        if (breakEvens.length === 0) return 0;

        return breakEvens.reduce((sum, val) => sum + val, 0) / breakEvens.length;
    }

    private detectPatterns(history: any[]): string[] {
        const patterns: string[] = [];

        if (history.length === 0) return patterns;

        const autoRebalances = history.filter(r => r.reasonCode === 'AUTO');
        if (autoRebalances.length > history.length * 0.7) {
            patterns.push('Automated rebalances have 70%+ success rate');
        }

        const outOfRange = history.filter(r => r.reasonCode === 'OUT_OF_RANGE');
        if (outOfRange.length > 0) {
            patterns.push('Out-of-range rebalances are always necessary');
        }

        const recent = history.slice(-5);
        const recentSuccessful = recent.filter(r => {
            const roi = r.feesClaimedUsd / r.transactionCostUsd;
            return roi >= 2.0;
        });
        if (recentSuccessful.length >= 4) {
            patterns.push('Recent rebalances show strong 80%+ success rate');
        }

        return patterns;
    }

    /**
     * Build context for position creation analysis
     */
    private async buildCreationContext(poolInfo: any): Promise<PoolCreationContext> {
        const { priceService } = require('./price.service');
        const { fetchPoolVolume } = require('./meteoraVolume.service');

        // Get pool basic info
        const poolAddress = poolInfo.address || poolInfo.pubkey?.toString();
        const tokenX = poolInfo.tokenX?.symbol || 'TokenX';
        const tokenY = poolInfo.tokenY?.symbol || 'TokenY';
        const tokenXMint = poolInfo.tokenX?.mint || poolInfo.mint_x;
        const tokenYMint = poolInfo.tokenY?.mint || poolInfo.mint_y;
        const currentPrice = poolInfo.currentPrice || 0;
        const binStep = poolInfo.binStep || 0;

        // Fetch price history (30 days) - Try CoinGecko first, then Birdeye
        let priceHistory = null;

        // Strategy 1: Try CoinGecko (works for major tokens)
        try {
            const coinGeckoId = await priceService.getCoinGeckoId(tokenX);
            if (coinGeckoId) {
                priceHistory = await priceService.getPriceHistory(coinGeckoId, 30);
                console.log(chalk.gray('  ‚úì Fetched 30-day history from CoinGecko'));
            }
        } catch (error) {
            // CoinGecko failed, will try Birdeye
        }
        try {
            console.log(chalk.gray('  ‚è≥ Trying DexScreener API...'));
            const axios = require('axios');

            // DexScreener pair info includes chart data
            const dexUrl = `https://api.dexscreener.com/latest/dex/tokens/${tokenXMint}`;
            const response = await axios.get(dexUrl, { timeout: 10000 });

            if (response.data && response.data.pairs && response.data.pairs.length > 0) {
                const pair = response.data.pairs[0];

                // DexScreener doesn't provide historical OHLC easily, but we can use current data
                // and estimate based on 24h change
                if (pair.priceChange && pair.priceChange.h24) {
                    const currentPriceFromDex = parseFloat(pair.priceUsd || currentPrice);
                    const change24h = parseFloat(pair.priceChange.h24) / 100;

                    // Generate approximate 30-day history based on recent volatility
                    priceHistory = [];
                    for (let i = 30; i >= 0; i--) {
                        const variance = (Math.random() - 0.5) * change24h * 2; // Random walk
                        const estimatedPrice = currentPriceFromDex * (1 + (variance * i / 30));
                        priceHistory.push({
                            timestamp: Date.now() - (i * 24 * 60 * 60 * 1000),
                            price: estimatedPrice
                        });
                    }
                    console.log(chalk.yellow('  ‚ÑπÔ∏è  Using estimated price history from DexScreener'));
                }
            }
        } catch (dexError) {
            console.log(chalk.yellow('  ‚ÑπÔ∏è  DexScreener also unavailable'));
        }
    }

    // Final fallback: If ALL APIs failed, use current price only
    if(!priceHistory || priceHistory.length === 0) {
    console.log(chalk.red('  ‚ö†Ô∏è  No price history available - using current price only'));
    priceHistory = [{
        timestamp: Date.now(),
        price: currentPrice
    }];
}

// Calculate volatility and trend
let volatility = 0;
let trend: 'bullish' | 'bearish' | 'neutral' = 'neutral';
let min = currentPrice;
let max = currentPrice;

if (priceHistory && priceHistory.length > 1) {
    const prices = priceHistory.map((p: any) => p.price);
    min = Math.min(...prices);
    max = Math.max(...prices);
    const mean = prices.reduce((a: number, b: number) => a + b, 0) / prices.length;
    const squaredDiffs = prices.map((p: number) => Math.pow(p - mean, 2));
    const variance = squaredDiffs.reduce((a: number, b: number) => a + b, 0) / prices.length;
    volatility = Math.sqrt(variance) / mean;

    // Determine trend
    const firstHalf = prices.slice(0, Math.floor(prices.length / 2));
    const secondHalf = prices.slice(Math.floor(prices.length / 2));
    const firstAvg = firstHalf.reduce((a: number, b: number) => a + b, 0) / firstHalf.length;
    const secondAvg = secondHalf.reduce((a: number, b: number) => a + b, 0) / secondHalf.length;

    if (secondAvg > firstAvg * 1.05) trend = 'bullish';
    else if (secondAvg < firstAvg * 0.95) trend = 'bearish';
}

// Fetch volume data
let volumeData = null;
try {
    volumeData = await fetchPoolVolume(poolAddress);
} catch (error) {
    volumeData = {
        volume24h: 0,
        volume7d: 0,
        volumeRatio: 1.0
    };
}

const volumeTrend = volumeData.volumeRatio > 1.2 ? 'increasing' :
    volumeData.volumeRatio < 0.8 ? 'decreasing' : 'stable';

// Check if stablecoin pair
const stableSymbols = ['USDC', 'USDT', 'DAI', 'USDC.E', 'USDT.E', 'USDH'];
const isStablePair = stableSymbols.includes(tokenX) && stableSymbols.includes(tokenY);
const hasStable = stableSymbols.includes(tokenX) || stableSymbols.includes(tokenY);

return {
    timestamp: Date.now(),
    pool: {
        address: poolAddress,
        tokenX,
        tokenY,
        binStep,
        currentPrice,
        activeBinId: poolInfo.activeBinId || 0,
        tvl: poolInfo.tvl || 0,
        apr: poolInfo.apr || 0
    },
    market: {
        priceHistory30d: {
            min,
            max,
            current: currentPrice,
            volatility,
            trend
        },
        volume: {
            current24h: volumeData.volume24h,
            avg7d: volumeData.volume7d / 7,
            ratio: volumeData.volumeRatio,
            trend: volumeTrend
        },
        technicals: {
            atr: volatility * currentPrice,
            atrState: trend === 'neutral' ? 'flat' : 'expanding',
            supportLevels: [min, min + (currentPrice - min) * 0.5],
            resistanceLevels: [currentPrice + (max - currentPrice) * 0.5, max]
        }
    },
    pairCharacteristics: {
        isStablePair,
        hasStable,
        volatilityScore: volatility * 100,
        volumeSkew: 0  // Default, would need order book data
    }
};
    }

    /**
     * Get LLM recommendation for position creation
     */
    private async getCreationRecommendation(context: PoolCreationContext): Promise < PoolCreationRecommendation > {
    const systemPrompt = this.buildCreationSystemPrompt();
    const userMessage = this.buildCreationUserMessage(context);

    const provider = this.providerConfig?.provider;

    let responseText = '';

    try {
        if(provider === 'anthropic') {
    const response = await this.client.messages.create({
        model: this.providerConfig!.model,
        max_tokens: 2048,
        messages: [{
            role: 'user',
            content: systemPrompt + '\n\n' + userMessage
        }]
    });
    responseText = response.content[0].text;
} else {
    // OpenAI-compatible
    const response = await this.client.chat.completions.create({
        model: this.providerConfig!.model,
        messages: [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: userMessage }
        ],
        temperature: 0.7,
        max_tokens: 2048
    });
    responseText = response.choices[0].message.content || '';
}

return this.parseCreationRecommendation(responseText, context);
        } catch (error: any) {
    // Enhanced error diagnostics
    console.log(chalk.red(`\n‚ùå LLM API Error Details:`));
    console.log(chalk.gray(`   Provider: ${provider}`));
    console.log(chalk.gray(`   Model: ${this.providerConfig?.model}`));

    if (error.response) {
        console.log(chalk.gray(`   Status: ${error.response.status}`));
        console.log(chalk.gray(`   Message: ${error.response.data?.error?.message || error.message}`));
    } else if (error.message) {
        console.log(chalk.gray(`   Error: ${error.message}`));
    }

    console.log(chalk.yellow(`\nüí° Suggestions:`));
    console.log(chalk.gray(`   1. Check your LLM configuration: npm run cli ‚Üí LLM AI Selection`));
    console.log(chalk.gray(`   2. Verify your API key is valid`));
    console.log(chalk.gray(`   3. Check your internet connection`));
    console.log(chalk.gray(`   4. For now, using algorithmic fallback\n`));

    throw error; // Re-throw to be caught by analyzePoolForCreation
}
    }

    /**
     * Build system prompt for creation analysis
     */
    private buildCreationSystemPrompt(): string {
    return `You are an expert DeFi liquidity provider strategist for Meteora DLMM pools.

Your role is to analyze pools and recommend optimal position configurations for new liquidity providers.

AVAILABLE STRATEGIES:
1. **Spot**: Symmetric liquidity around current price. Best for normal volatility pairs.
2. **Curve**: Tight concentrated range. Best for stablecoin pairs (USDC/USDT).
3. **BidAsk**: Asymmetric liquidity (more on one side). Best for trending/directional pairs.

DECISION FACTORS:
- Volatility: High volatility ‚Üí wider ranges or BidAsk
- Pair Type: Stablecoins ‚Üí Curve, Volatile ‚Üí Spot or BidAsk
- Market Trend: Bullish ‚Üí more Ask side, Bearish ‚Üí more Bid side
- Volume: High volume ‚Üí tighter ranges for more fee capture

OUTPUT FORMAT (JSON):
{
  "strategy": "Spot|Curve|BidAsk",
  "confidence": 85,
  "reasoning": ["Volume trending up...", "Volatility moderate..."],
  "binConfiguration": {
    "minBinId": 350,
    "maxBinId": 400,
    "bidBins": 20,
    "askBins": 30,
    "totalBins": 50
  },
  "liquidityDistribution": {
    "tokenXPercentage": 40,
    "tokenYPercentage": 60,
    "isAsymmetric": true
  },
  "expectedPerformance": {
    "estimatedAPR": 22.5,
    "feeEfficiency": 85,
    "rebalanceFrequency": "medium"
  },
  "risks": ["Price could trend down...", "High gas costs if..."],
  "marketRegime": "Bullish Trending"
}`;
}

    /**
     * Build user message for creation analysis
     */
    private buildCreationUserMessage(ctx: PoolCreationContext): string {
    return `Analyze this pool for optimal position creation:

POOL: ${ctx.pool.tokenX}/${ctx.pool.tokenY}
Current Price: $${ctx.pool.currentPrice.toFixed(4)}
Bin Step: ${ctx.pool.binStep} bps
TVL: $${(ctx.pool.tvl / 1000000).toFixed(2)}M
Current APR: ${ctx.pool.apr.toFixed(2)}%

30-DAY PRICE HISTORY:
- Min: $${ctx.market.priceHistory30d.min.toFixed(4)}
- Max: $${ctx.market.priceHistory30d.max.toFixed(4)}
- Volatility: ${(ctx.market.priceHistory30d.volatility * 100).toFixed(2)}%
- Trend: ${ctx.market.priceHistory30d.trend}

VOLUME:
- 24h Volume: $${(ctx.market.volume.current24h / 1000).toFixed(1)}K
- 7d Avg: $${(ctx.market.volume.avg7d / 1000).toFixed(1)}K
- Ratio: ${ctx.market.volume.ratio.toFixed(2)}x
- Trend: ${ctx.market.volume.trend}

TECHNICALS:
- ATR: ${ctx.market.technicals.atr.toFixed(4)} (${ctx.market.technicals.atrState})
- Support: [${ctx.market.technicals.supportLevels.map(l => '$' + l.toFixed(2)).join(', ')}]
- Resistance: [${ctx.market.technicals.resistanceLevels.map(l => '$' + l.toFixed(2)).join(', ')}]

PAIR CHARACTERISTICS:
- Stablecoin Pair: ${ctx.pairCharacteristics.isStablePair ? 'YES' : 'NO'}
- Has Stable: ${ctx.pairCharacteristics.hasStable ? 'YES' : 'NO'}
- Volatility Score: ${ctx.pairCharacteristics.volatilityScore.toFixed(2)}%

Recommend the optimal strategy, bin configuration, and explain your reasoning.`;
}

    /**
     * Parse LLM response for creation recommendation
     */
    private parseCreationRecommendation(text: string, context: PoolCreationContext): PoolCreationRecommendation {
    try {
        // Extract JSON from response
        const jsonMatch = text.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
            const parsed = JSON.parse(jsonMatch[0]);
            return parsed as PoolCreationRecommendation;
        }
    } catch (error) {
        // Fallback parsing
    }

    // Return default recommendation
    return this.getMockCreationRecommendation(context);
}

    /**
     * Get mock creation recommendation when LLM unavailable
     */
    private getMockCreationRecommendation(poolInfo: any): PoolCreationRecommendation {
    const currentPrice = poolInfo.currentPrice || poolInfo.pool?.currentPrice || 0;
    const activeBinId = poolInfo.activeBinId || poolInfo.pool?.activeBinId || 0;
    const tokenX = poolInfo.tokenX?.symbol || poolInfo.pool?.tokenX || 'TokenX';
    const tokenY = poolInfo.tokenY?.symbol || poolInfo.pool?.tokenY || 'TokenY';

    // Simple heuristic-based recommendation
    const stableSymbols = ['USDC', 'USDT', 'DAI'];
    const isStablePair = stableSymbols.includes(tokenX) && stableSymbols.includes(tokenY);

    let strategy: 'Spot' | 'Curve' | 'BidAsk' = 'Spot';
    let bidBins = 29;
    let askBins = 29;

    if (isStablePair) {
        strategy = 'Curve';
        bidBins = 69;
        askBins = 69;
    }

    return {
        strategy,
        confidence: 70,
        reasoning: [
            `Algorithmic recommendation (LLM unavailable)`,
            isStablePair ? 'Stablecoin pair detected ‚Üí Curve strategy' : 'Normal pair ‚Üí Spot strategy',
            `Symmetric range recommended`
        ],
        binConfiguration: {
            minBinId: activeBinId - bidBins,
            maxBinId: activeBinId + askBins,
            bidBins,
            askBins,
            totalBins: bidBins + askBins
        },
        liquidityDistribution: {
            tokenXPercentage: 50,
            tokenYPercentage: 50,
            isAsymmetric: false
        },
        expectedPerformance: {
            estimatedAPR: poolInfo.apr || 0,
            feeEfficiency: 75,
            rebalanceFrequency: 'medium'
        },
        risks: [
            'Price volatility may cause frequent rebalancing',
            'Market conditions may change'
        ],
        marketRegime: 'Unknown (LLM not configured)'
    };
}
}

export const llmAgent = new LLMAgentService();
